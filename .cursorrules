# dStruct Project - Cursor Rules

## Project Overview

dStruct is a LeetCode problem visualization web app with data structure visualization, code execution, and interactive learning tools.

## Technology Stack

- **Frontend**: React, Next.js, TypeScript
- **State Management**: Redux Toolkit with RTK Query
- **Styling**: Tailwind CSS, Material-UI, Emotion, SCSS
- **Database**: Prisma ORM with MySQL
- **Authentication**: NextAuth.js
- **API**: tRPC, GraphQL with Apollo Client
- **Testing**: Vitest with Testing Library
- **Package Manager**: PNPM (always use PNPM, never NPM)

## Architecture Patterns

### Project Structure

```
src/
├── entities/          # Domain entities and business logic
├── features/          # Feature-based modules with UI/model separation
├── shared/            # Shared utilities, hooks, and components
├── store/             # Redux store configuration
├── server/            # Backend API (tRPC, GraphQL)
├── context/           # React Context providers
└── pages/             # Next.js pages and API routes
```

### State Management

- Use Redux Toolkit for global state with slices
- Use RTK Query for server state management
- Keep local component state with React hooks when appropriate

### Data Flow

- Entities contain business logic and data models
- Features contain UI components and feature-specific state
- Shared utilities provide common functionality
- Use tRPC for type-safe API calls

## Coding Standards

### TypeScript

- **ALWAYS** use TypeScript - no JavaScript files
- Use proper type annotations, avoid `any`
- Use type imports: `import type { ... } from "..."`
- Define proper interfaces and types for all data structures

### React Patterns

- Use functional components with hooks
- Implement proper prop typing
- Use React.forwardRef when needed
- Use proper dependency arrays in useEffect/useMemo/useCallback

### Component Architecture

- Follow atomic design: atoms → molecules → organisms → templates
- Keep components focused and single-responsibility
- Use composition over inheritance
- Implement proper prop drilling alternatives (Context, Redux)

### Styling

- Use Tailwind CSS as primary styling solution
- Leverage Material-UI components when appropriate
- Use CSS modules for component-specific styles
- Follow design system color palette from `src/shared/lib/colors.ts`
- Use `cn()` utility for conditional class merging

## File Naming & Organization

### Naming Conventions

- **Files**: kebab-case for files, PascalCase for components
- **Components**: PascalCase (e.g., `BinaryNode.tsx`)
- **Hooks**: camelCase with `use` prefix (e.g., `useBinaryTreePositioning.ts`)
- **Utilities**: camelCase (e.g., `getNodeColors.ts`)
- **Types**: PascalCase with descriptive names

### Import Organization

- Use absolute imports with `#/` alias for src directory
- Group imports: external → internal → relative
- Use barrel exports in index files
- Avoid circular dependencies

## Code Quality

### Linting & Formatting

- Follow ESLint configuration in `eslint.config.mjs`
- Use Prettier for code formatting
- Run `pnpm lint` before committing

### Testing

- Write tests for business logic and complex components
- Use Vitest with Testing Library
- Test user interactions, not implementation details
- Avoid testing constants or static values
- Use proper test setup and mocking

### Performance

- Implement proper memoization with useMemo/useCallback
- Use React.memo for expensive components
- Optimize bundle size with dynamic imports
- Implement proper loading states and error boundaries

## Database & API

### Prisma

- Use Prisma for all database operations
- Generate client after schema changes: `pnpm prisma:generate`
- Use proper typing for database models
- Implement proper error handling

### tRPC

- Use tRPC for type-safe API calls
- Define proper input/output schemas
- Use protected procedures for authenticated routes
- Implement proper error handling and validation

### GraphQL

- Use GraphQL for complex queries
- Generate types with GraphQL Code Generator
- Use Apollo Client for GraphQL operations

## Security & Best Practices

### Authentication

- Use NextAuth.js for authentication
- Implement proper session management
- Use protected routes for sensitive operations
- Validate user permissions

### Environment Variables

- Use Zod schemas for environment validation
- Never commit sensitive data
- Update schema in `src/env/schema.mjs` when adding new vars

### Data Validation

- Use Zod for runtime validation
- Validate all user inputs
- Implement proper error handling
- Use TypeScript for compile-time validation

## 3D Visualization

### Blender Integration

- Store 3D models in `blender/` directory
- Export as .glb files
- Use gltfjsx to convert to React components
- Follow naming convention: `ModelName.tsx`

### Three.js Usage

- Use @react-three/fiber and @react-three/drei
- Implement proper performance optimizations
- Handle loading states and errors
- Use proper lighting and materials

## Development Workflow

### Git & Deployment

- Use semantic commit messages
- Follow conventional commits for releases
- Use Husky for pre-commit hooks

### Dependencies

- Always use PNPM for package management
- Keep dependencies up to date
- Use exact versions for critical packages

### Build & Development

- Use `pnpm dev` for development
- Use `pnpm build` for production builds
- Run tests with `pnpm test`

## Common Patterns

### State Management

```typescript
// Redux slice pattern
export const exampleSlice = createSlice({
  name: "EXAMPLE",
  initialState,
  reducers: {
    update: (state, action: PayloadAction<Partial<State>>) => ({
      ...state,
      ...action.payload,
    }),
  },
});
```

### Component Structure

```typescript
// Component with proper typing
interface ComponentProps {
  title: string;
  onAction: (data: ActionData) => void;
}

export const Component: React.FC<ComponentProps> = ({ title, onAction }) => {
  // Component implementation
};
```

### Hook Pattern

```typescript
// Custom hook with proper typing
export const useCustomHook = (): ReturnType => {
  // Hook implementation
  return result;
};
```

## Error Handling

### Client-Side

- Implement proper error boundaries
- Use try-catch for async operations
- Provide user-friendly error messages
- Log errors appropriately

### Server-Side

- Use proper HTTP status codes
- Implement proper error logging
- Return structured error responses
- Handle edge cases gracefully

## Performance Considerations

### Code Splitting

- Use dynamic imports for large components
- Implement proper loading states
- Optimize bundle size
- Use Next.js built-in optimizations

### Data Fetching

- Implement proper caching strategies
- Use RTK Query for server state
- Implement optimistic updates
- Handle loading and error states

## Internationalization

### i18n Implementation

- Use typesafe-i18n for translations
- Support multiple locales: en, ru, de, es, sr, uk
- Implement proper locale detection
- Use translation keys consistently

## Testing Strategy

### Test Organization

- Place tests in `__tests__` directories
- Use descriptive test names
- Test user behavior, not implementation
- Mock external dependencies properly

### Test Utilities

- Use Testing Library for component testing
- Implement proper test setup
- Use custom render functions with providers
- Mock Next.js router and authentication

## Documentation

### Code Documentation

- Use JSDoc for complex functions
- Document component props and interfaces
- Keep README and documentation updated
- Document complex business logic

### API Documentation

- Document tRPC procedures
- Document GraphQL schema
- Provide usage examples
- Keep API documentation current

## Feature Design & Implementation

### Design Documentation

- **ALWAYS** create design documents in `vibe-docs/` directory before implementation
- Design docs must include:
  - Executive summary and current state analysis
  - Functional and technical requirements
  - Architecture design (component structure, state management, API design)
  - UI/UX mockups and interaction patterns
  - Implementation phases with difficulty ratings (0-10 scale)
  - Performance considerations and optimization strategies
  - I18n and A11y requirements
  - Testing strategy
  - Migration/deprecation plans if applicable

### TODO Tracking

- **ALWAYS** create a separate TODO file (`vibe-docs/{FeatureName}-TODO.md`) alongside design docs
- TODO files must:
  - Break down implementation into phases
  - Include checkboxes for each task
  - Track progress systematically
  - Include difficulty ratings (0-10) for complex tasks
  - Reference related design doc sections

### Technology Stack Adherence

- **NEVER** introduce new major libraries without justification
- When considering new dependencies:
  - Document bundle size impact (use `pnpm why` and bundle analyzers)
  - List pros/cons vs existing solutions
  - Assess difficulty of integration (0-10 scale)
  - Check compatibility with existing stack (MUI, tRPC, Next.js, etc.)
  - Prefer existing solutions: MUI components, tRPC procedures, Redux Toolkit

### Difficulty Assessment

- Rate implementation difficulty on 0-10 scale:
  - **0-2**: Trivial (simple UI changes, copy-paste patterns)
  - **3-4**: Easy (standard patterns, existing components)
  - **5-6**: Medium (new components, moderate complexity)
  - **7-8**: Hard (complex logic, performance optimization, integration)
  - **9-10**: Very Hard (architectural changes, new patterns, high risk)
- Include difficulty in design docs and TODO files
- Break down complex tasks (7+) into smaller subtasks

### Diagrams & Schemas

- Create visual documentation when applicable:
  - **Component hierarchy diagrams** (Mermaid or ASCII art)
  - **Data flow diagrams** (state management, API calls)
  - **Database relation schemes** (Prisma schema visualizations)
  - **User flow diagrams** (interaction patterns)
- Store diagrams in `vibe-docs/` as markdown with Mermaid or images
- Use Mermaid syntax for version-controlled diagrams:
  ```mermaid
  graph TD
    A[Component] --> B[Child Component]
  ```

### I18n Requirements

- **ALWAYS** use typesafe-i18n for all user-facing strings
- Follow existing pattern:
  - Add keys to `src/i18n/en/index.ts`
  - Use `LL.KEY_NAME()` pattern in components
  - Support all locales: en, ru, de, es, sr, uk
  - **IMPORTANT**: `pnpm typesafe-i18n` runs as a file watcher and does NOT exit by itself
  - After adding translation keys, instruct user to run `pnpm typesafe-i18n` manually (or run in background)
  - Do NOT run `pnpm typesafe-i18n` directly in terminal commands as it will hang
- Never hardcode strings in components
- Document all new translation keys in design docs

### Accessibility (A11y) Requirements

- **ALWAYS** implement accessibility features:
  - ARIA labels and roles for interactive elements
  - Keyboard navigation (Tab, Enter, Arrow keys, Escape)
  - Screen reader support with descriptive text
  - Focus management and visible focus indicators
  - Semantic HTML structure
  - Color contrast ratios (WCAG AA minimum)
- Test with keyboard-only navigation
- Use MUI's built-in accessibility features
- Document A11y features in design docs

### Performance Considerations

- For data-heavy features (lists, tables, filters):
  - Use virtualization (`react-virtuoso`) for large lists
  - Implement server-side pagination
  - Debounce search/filter inputs (200-300ms)
  - Memoize expensive computations
  - Use React.memo for expensive components
- Document performance optimizations in design docs
- Include bundle size impact analysis

### API Design (tRPC)

- Follow existing tRPC patterns:
  - Use `publicProcedure` or `protectedProcedure`
  - Validate inputs with Zod schemas
  - Return typed responses
  - Handle errors with TRPCError
- For pagination:
  - Use `page` and `pageSize` parameters
  - Return `{ data, total, hasMore }` structure
- Document API endpoints in design docs with:
  - Input/output schemas
  - Example usage
  - Error cases

### Component Architecture

- Follow feature-based structure:
  ```
  src/features/{feature}/
  ├── ui/
  │   └── {FeatureName}/
  │       ├── {FeatureName}.tsx
  │       └── {FeatureName}*.tsx (sub-components)
  ├── model/
  │   └── {feature}Slice.ts (Redux)
  └── hooks/
      └── use{FeatureName}.ts
  ```
- Keep components focused and composable
- Use MUI components consistently
- Follow existing patterns from similar features

### State Management

- Use Redux Toolkit for:
  - Global UI state (filters, selections, modals)
  - Complex state that needs persistence
  - State shared across multiple components
- Use React hooks for:
  - Local component state
  - Form state (consider Formik if complex)
  - Temporary UI state (hover, focus)
- Use tRPC queries for:
  - Server state
  - Data fetching
  - Caching and invalidation

### Testing Requirements

- **ALWAYS** write unit tests after implementing features
- Write tests for:
  - Business logic functions
  - Complex components with user interactions
  - Redux slice reducers
  - Custom hooks
  - API endpoint handlers (tRPC procedures)
- Use Vitest with Testing Library
- Test user behavior, not implementation
- Avoid testing constants or TypeScript types
- **Generate mock data** where applicable:
  - Use factories/builders for test data
  - Create reusable mock generators
  - Mock external dependencies (APIs, databases)
  - Use realistic test data that matches production structure
- Focus on **most essential tests**:
  - Critical user flows
  - Edge cases and error handling
  - State transitions
  - Integration points
- Document test strategy in design docs:
  - What will be tested
  - Mock data structure
  - Test coverage goals
  - Testing approach (unit/integration/E2E)

### Migration & Backward Compatibility

- When replacing existing features:
  - Keep old components for backward compatibility
  - Add feature flags if needed
  - Document migration path
  - Plan deprecation timeline
- Update related components gradually
- Maintain API compatibility when possible

## Remember

- Always use TypeScript
- Follow the established architecture patterns
- Use PNPM for package management
- Write meaningful tests
- Keep code clean and maintainable
- Follow security best practices
- Optimize for performance
- Maintain proper error handling
- Use proper typing throughout
- Follow the project's established conventions
- **ALWAYS** create design docs in `vibe-docs/` before major features
- **ALWAYS** create TODO files to track implementation progress
- **ALWAYS** assess difficulty and document bundle impact for new dependencies
